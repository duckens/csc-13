#pragma config(Sensor, S3,     ,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define motorLeft motorA
#define motorRight motorB
#define sonnarId S3

int basicDist;
int extremeMinimumDist = 25;
int getSonnarValue();
void getBasicValue();
void wallRide();
void setOutputOnMotors(int l, int r);
void showSensor();
int weighedSumm(int arg_x, int arg_y);
int sonnarValueEnvelope;

const float prop_coeff = 2.0;
const float diff_coeff = 5.0;
const float basicSpeed = 75.0;
const float d = 15.0;
const float a = 0.5;

int oldDist;
const int deltaT = 1;

void getBasicValue(){
	int basicValue = getSonnarValue();
	if(basicValue < extremeMinimumDist) basicValue = extremeMinimumDist;
	oldDist = basicValue;
	basicDist = basicValue;
	sonnarValueEnvelope = basicValue;
}

int weighedSumm(int arg_x, int arg_y){
	return arg_x * (1.0 - a) + arg_y * a;
}

int getSonnarValue(){
	int realSonnarValue = SensorValue[sonnarId];
	//sonnarValueEnvelope = weighedSumm(sonnarValueEnvelope, realSonnarValue);
	//return sonnarValueEnvelope;
	return realSonnarValue;
}

int getSonnarValueEnvelope(){
	int realSonnarValue = SensorValue[sonnarId];
	sonnarValueEnvelope = weighedSumm(sonnarValueEnvelope, realSonnarValue);
	return sonnarValueEnvelope;
}

void setOutputOnMotors(int l, int r){
	motor[motorLeft] = l;
	motor[motorRight] = r;
}

void showSensor(){
	nxtDisplayTextLine(0, "sonnar = %d", getSonnarValueEnvelope());
}
void showTypeOfOperation(string str){
	nxtDisplayTextLine(1, str);
}

void showCorrection(int cor){
	nxtDisplayTextLine(2, "corr = %d", cor);
}

void mathCalculations(const int currentDist, float& prop_correction, float& diff_correction){
	float prop_discrapency = currentDist - basicDist;
	prop_correction = prop_discrapency * prop_coeff;

	float diff_discrapency = currentDist - oldDist;
	diff_correction = diff_discrapency* diff_coeff;
}

void wallRide(){



	float correction;
	float prop_correction;
	float diff_correction;

	string strings[3] = {"extreme", "corner", "normal"};
	int typeOfOperation;

	int currentDist = getSonnarValueEnvelope();
	mathCalculations(currentDist, prop_correction, diff_correction);

	if( currentDist  < extremeMinimumDist ){
		/**************************************************************
		***********************EXTREAMLY NEAR**************************
		**************************************************************/

		correction = prop_correction + diff_correction;

		float howFar = (extremeMinimumDist - currentDist) / extremeMinimumDist;
		int speed = (1 - howFar) * basicSpeed;

		setOutputOnMotors(speed + correction, speed - correction);
		typeOfOperation = 0;

	} else if( currentDist > basicDist * 2 ){

		/**************************************************************
		***********************PASSING CORNER**************************
		**************************************************************/

		correction = basicSpeed * d / basicDist;

		oldDist = 2 * basicSpeed;

		setOutputOnMotors(basicSpeed + correction, basicSpeed - correction);
		typeOfOperation = 1;

	} else {
		/**************************************************************
		**********************NORMAL OPERATION*************************
		**************************************************************/

		correction = prop_correction + diff_correction;
		oldDist = currentDist;

		setOutputOnMotors(basicSpeed + correction, basicSpeed - correction);
		typeOfOperation = 2;

	}

	showTypeOfOperation(strings[typeOfOperation]);
	showCorrection(correction);


}

task paintGraph(){
	for (int x = 0; x<49;++x){
		int y = getSonnarValue() / 4;
		nxtSetPixel(x,y);
		y = getSonnarValueEnvelope() / 4;
		nxtSetPixel(50 + x,y);
		wait1Msec(20);
	}
}

task main()
{
	getBasicValue();
	// StartTask(paintGraph);

	while(1){
		wallRide();
		showSensor();
		//setOutputOnMotors(0, 50);
		wait1Msec(deltaT);
	}


}
