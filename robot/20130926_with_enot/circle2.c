#pragma config(Sensor, S1,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void func(float B, float C, float dB, float dC, int time);
void setOutput(int B, int C);
void accelerate(int speed);
void rotate(int speedRotate);
void rotateBlockLeft();

void func(float B, float C, float dB, float dC, int time)
{
	for(int i = 1 ; i <= time ; i++)
	{
		B += dB;
		C += dC;
		motor[motorB] = B;
		motor[motorC] = C;
		wait1Msec(1);
	}
}


int curSpeed = 0;
int curRotate = 0;
const int dv = 2;
int blockSize = 50;

void setOutput(int B, int C){
	motor[motorB] = B;
	motor[motorC] = C;
}

void accelerate(int speed){
	if(curRotate){
		rotate(0);
	}
	int delta = (speed - curSpeed);
	int dv_here = delta / abs(delta) * dv;
	while(speed - curSpeed != 0){
		curSpeed += dv_here;
		setOutput(curSpeed, curSpeed);

		wait1Msec(10);
	}
}

void rotate(int speedRotate){
	if(curSpeed){
		accelerate(0);
	}
	int delta = (speedRotate - curRotate);
	int dv_here = delta / abs(delta) * dv;
	while(speedRotate - curRotate != 0){
		curRotate += dv_here;
		setOutput(curRotate, -curRotate);
		wait1Msec(10);
	}
}

void rotateBlockLeft(){
	rotate(20);
	wait1Msec(10);
	rotate(0);
}

task main()
{

	//int white = SensorValue[S1];
	/*
	func(0, 0, 1, 1, 100);
	while(true)
	{
		motor[motorB] = 100;
		motor[motorC] = 100;
		while(SensorValue[S1] > white - 8);
		func(100, 100, -1, -1, 200);
		wait1Msec(300);
		func(100, 100, 1, 0, 200);
		wait1Msec(400);
		func(100, 100, 0, 1, 200);
	}
	*/

	/*
	int white = SensorValue[S1];
	while(true)
	{
		curSpeed = 0;
		curRotate = 0;
		accelerate(100);
		while(SensorValue[S1] > white - 8);
		accelerate(-100);
		wait1Msec(300);
		rotate(50);
		wait1Msec(400);
		accelerate(100);
	}
	*/
	int white = SensorValue[S1];
	while(1){
		int localMin = SensorValue[S4];
		while(SensorValue[S4] <= localMin){
			localMin = SensorValue[S4];
			rotateBlockLeft();
		}
		accelerate(100);
		while(SensorValue[S1] > white - 8);
		accelerate(-100);
		wait1Msec(300);
	}
}
