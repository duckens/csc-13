#pragma config(Sensor, S1,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


const int motorLeftIndex = motorB;
const int motorRightIndex = motorA;

const int sensorLightIndex = S1;
const int sensorDistIndex = S4;

int speed;
int rudder;

int motorLeft;
int motorRight;

void setOutputOnMotors(int l, int r);
void movenment_init();
void go(int desiredSpeed, int desiredTurn);

int max(int x, int y){
	if(x > y)	return x;
	return y;
}

int min(int x, int y){
	if(x < y)	return x;
	return y;
}

void setOutputOnMotors(int l, int r){
	if(abs(l) > 100){
		l = 100 * l / abs(l);
	}
	if(abs(r) > 100){
		r = 100 * r / abs(r);
	}
	motor[motorLeftIndex] = l;
	motor[motorRightIndex] = r;
}


void movenment_init(){
	motorLeft = 0;
	motorRight = 0;
	speed = 0;
	rudder = 0;
}

int rudderOfTurn(int desiredSpeed, int desiredTurn){
	int res = (int)( (float)desiredTurn / 5);
	return res;
}

void go(int desiredSpeed, int desiredTurn){
	rudder = rudderOfTurn(desiredSpeed, desiredTurn);
	speed = desiredSpeed;
	motorLeft = speed + rudder;
	motorRight = speed - rudder;

	setOutputOnMotors(motorLeft, motorRight);
}



float baseCoeff = 40;
float coeff = baseCoeff;

float baseDiffCoeff = 300;
float diffCoeff = baseDiffCoeff;

float baseCubeCoeff = 0.3;
float cubeCoeff = baseCubeCoeff;

int grey = 30;

int baseSpeed = 100;
int maxSpeed = 100;

float curSpeed = baseSpeed;

int curSensor;
int oldSensor;

int leftSide = 1;

const int baseDist = -20;
const int signalDist = 20;
const int maxDist = 100;
bool doBeep = false;



int propRegulator(){
	return (int)( coeff * (curSensor - grey) );
}

int diffRegulator(){
	return diffCoeff * (curSensor - oldSensor);
}

int cubeRegulator(){
	int diff = (curSensor - grey);
	return cubeCoeff * diff * diff * diff;
}


void calibrate(){
	int maxim = SensorValue[S1];
	int minim = SensorValue[S1];
	for(int i = 0; i < 4000; i++){

	}
}


task beep(){
	while(1){
		if(doBeep){
			PlaySound(soundUpwardTones);
		}
		wait1Msec(1000);
	}
}

int getDist(){
	int res = SensorValue[sensorDistIndex];
	if(res < signalDist){
		doBeep = true;
	} else {
		doBeep = false;
	}
	return res;
}

int getEncoderValue(){
	return nMotorEncoder[motorRightIndex];
}

void breakingGoRound(){
	nxtDisplayString(0, "breakingGoRound");

	const int howFarToTurn = 250;
	const int howFarToGoSide = 400;
	const int howFarToGoAhead = 650;

	int encoderValue = getEncoderValue();
	while(getEncoderValue() - encoderValue < howFarToTurn){
		setOutputOnMotors(-50, 50);
		wait1Msec(1);
	}
	go(0, 0);
	encoderValue = getEncoderValue();
	while(getEncoderValue() - encoderValue < howFarToGoSide){
		setOutputOnMotors(50, 50);
		wait1Msec(1);
	}
	go(0, 0);
	encoderValue = getEncoderValue();
	while(getEncoderValue() - encoderValue > -howFarToTurn){
		setOutputOnMotors(50, -50);
		wait1Msec(1);
	}
	go(0, 0);
	encoderValue = getEncoderValue();
	while(getEncoderValue() - encoderValue < howFarToGoAhead){
		setOutputOnMotors(50, 50);
		wait1Msec(1);
	}
	go(0, 0);
}

void breakingRotate(){
	nxtDisplayString(0, "breakingRotate");

	int encoderValue = getEncoderValue();
	while(getEncoderValue() - encoderValue < 700){
		setOutputOnMotors(-50, 50);
		wait1Msec(1);
	}

	/*
	for(int i = 0; i < 1000; i++){
		setOutputOnMotors(-30, 30);
		wait1Msec(1);
	}
	*/

	go(0, 0);
}

int speedRegulator(){
	int dist = getDist();
	if(dist > maxDist){
		return baseSpeed;
	} else {
		if(dist < signalDist){
			//breakingRotate();
			breakingGoRound();
		}
		return (int)( (float)baseSpeed * (float)(dist - baseDist) ) / (float)(maxDist - baseDist);
	}
}





task main(){
	nMotorEncoder[motorRight] = 0;

	movenment_init();
	StartTask(beep);

	while(1){

		oldSensor = curSensor;
		curSensor = SensorValue[S1];

		int discrapencyProportional = propRegulator();
		int discrapencyDifferential = diffRegulator();
		int discrapencyCube = cubeRegulator();

		int discrapency = discrapencyProportional + discrapencyDifferential + discrapencyCube;
		discrapency *= leftSide;

		curSpeed = speedRegulator();

		go(curSpeed, discrapency);
		nxtDisplayString(0, "go");
		wait1Msec(1);
	}
}
