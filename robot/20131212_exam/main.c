#pragma config(Sensor, S1,     ,               sensorLightActive)
#pragma config(Sensor, S2,     ,               sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


void killJar();
void killBall();
void fullStop();

bool ignoreCrossesAfterWall();

const int rotate90Dist = 260;
const int rotate10Dist = 40;
const int touchBallDist = 250;
const int touchJarDist = 160;

const int distanceB4TheWall = 3500;
const int distancePassTheWall = 2200;
const int distanceToStop = 100;

const int motorLeftIndex = motorB;
const int motorRightIndex = motorC;

const int sensorLightIndex_right = S1;
const int sensorLightIndex_left = S2;

bool crossDetected = 0;
bool waitingWall = false;

const int ARCTION_ON_CROSS_KILL_BALL = 0;
const int ARCTION_ON_CROSS_KILL_JAR = 1;
const int ARCTION_ON_CROSS_IGNORE = 2;
const int ARCTION_ON_CROSS_FULL_STOP = 3;


int actionsOnCrosses[] = {2, 0, 1, 1, 1, 2, 1, 3};
int lastCrossNumberB4Wall = 7;
int actionsOnCrosses_size = 8;

int crossNumber = 0;
bool wallPassed = false;

int getSensor();
//int speed;
//int rudder;

int motorLeft;
int motorRight;

int grey_left;
int grey_right;

int initialError;

void setOutputOnMotors(int l, int r);
void movenment_init();
void go(int desiredSpeed, int desiredTurn);

int max(int x, int y){
	if(x > y)	return x;
	return y;
}

int min(int x, int y){
	if(x < y)	return x;
	return y;
}

void setOutputOnMotors(int l, int r){
	if(abs(l) > 100){
		l = 100 * l / abs(l);
	}
	if(abs(r) > 100){
		r = 100 * r / abs(r);
	}
	motor[motorLeftIndex] = l;
	motor[motorRightIndex] = r;
}


void movenment_init(){
	crossNumber = 0;
	grey_left = SensorValue[sensorLightIndex_left] - 10;
	grey_right = SensorValue[sensorLightIndex_right] - 10;
	initialError = getSensor();
	setOutputOnMotors(0, 0)	;
}

int rudderOfTurn(int desiredSpeed, int desiredTurn){
	int res = (int)( (float)desiredTurn / 5);
	return res;
}

void go(int desiredSpeed, int desiredTurn){
	int rudder = rudderOfTurn(desiredSpeed, desiredTurn);
	int speed = desiredSpeed;
	motorLeft = speed + rudder;
	motorRight = speed - rudder;

	setOutputOnMotors(motorLeft, motorRight);
}




float coeff = 40;
float diffCoeff = 30;
float cubeCoeff = 0.03;
// float diffCoeff = 300;
// float cubeCoeff = 0.3;

// int grey = 30;

int baseSpeed = 80;
int maxSpeed = 100;

float curSpeed = baseSpeed;

int curSensor;
int oldSensor;

int leftSide = 1;



int propRegulator(){
	return (int)( coeff * (curSensor) );
}

int diffRegulator(){
	return diffCoeff * (curSensor - oldSensor);
}

int cubeRegulator(){
	int diff = (curSensor);
	return cubeCoeff * diff * diff * diff;
}

int currentEncoder;
int currentEncoderDelta;
const int currentEncoderDeltaBorder = 100;
const int encoderBorder = 400;
bool goCountingEncoders = 0;
//int summingCorrection;
//const int summingCorrectionBorder = 200;


void recountEncoder(){
	currentEncoder = (nMotorEncoder[motorRightIndex] + nMotorEncoder[motorLeftIndex]);
	currentEncoderDelta = (nMotorEncoder[motorRightIndex] - nMotorEncoder[motorLeftIndex]);
}

void treatWall(){
	nMotorEncoder[motorRightIndex] = 0;
	nMotorEncoder[motorLeftIndex] = 0;
	waitingWall = true;
}

void treatCrossDetected(){

	nMotorEncoder[motorRightIndex] = 0;
	nMotorEncoder[motorLeftIndex] = 0;
	goCountingEncoders = true;
	currentEncoderDelta = 0;
	currentEncoder = 0;
}

bool distancePassed(){
	if(currentEncoder > encoderBorder){
		return true;
	}
	return false;
}

int getSensor(){
	int res = SensorValue[sensorLightIndex_left] - SensorValue[sensorLightIndex_right];
	return res;
}

int getSensorCorrectingError(){
	return getSensor() - initialError;
}

void makeActionCorner(){
	//PlaySound(soundBeepBeep);
}

void makeAction(){
	//PlaySound(soundDownwardTones);
}


task countCrosses(){
	ClearTimer(T1);

	int count = 0;


	while(1){
		if(
			(time1[T1] > 200) &&
			(SensorValue[sensorLightIndex_left] < grey_left) &&
			(SensorValue[sensorLightIndex_right] < grey_right)
		){
			count++;
			ClearTimer(T1);

			if(!ignoreCrossesAfterWall()) crossDetected = true;
			//PlaySound(soundBeepBeep);

		}
		wait1Msec(1);
	}
}

void stabilize(){

		for(int i = 0; i < 100; i++){
			oldSensor = curSensor;
			curSensor = getSensorCorrectingError();

			go(0, leftSide * propRegulator());

			nxtDisplayString(0, "stabilize");

			wait1Msec(1);
		}
		go(0, 0);
		wait1Msec(100);
		nxtDisplayString(0, "kill");
}

bool timeToPrepareForWall(){
	if(wallPassed) return false;
	return (crossNumber ==	lastCrossNumberB4Wall);
}

bool wallStart(){
	if(wallPassed) return false;
	return nMotorEncoder[motorLeftIndex] > distanceB4TheWall;
}

void wall(){
		stabilize();
		stabilize();
		stabilize();
		stabilize();

		int wallSpeed = 50;
		nMotorEncoder[motorLeftIndex] = 0;
		motor[motorLeftIndex] = wallSpeed;
		motor[motorRightIndex] = -wallSpeed;
		while (nMotorEncoder[motorLeftIndex]<rotate10Dist){
			wait1Msec(10);
		}

		nMotorEncoder[motorLeftIndex] = 0;
		motor[motorLeftIndex] = wallSpeed;
		motor[motorRightIndex] = wallSpeed + 5;
		while (nMotorEncoder[motorLeftIndex]<distancePassTheWall){
			wait1Msec(10);
		}

		nMotorEncoder[motorLeftIndex] = 0;
		nMotorEncoder[motorRightIndex] = 0;
		wallPassed = true;
}

bool ignoreCrossesAfterWall(){
	if(!wallPassed) return false;
	if(nMotorEncoder[motorLeftIndex] < 500) return true;
	return false;
}

task main(){
	nMotorEncoder[motorRight] = 0;

	movenment_init();

	StartTask(countCrosses);

	while(1){

		oldSensor = curSensor;
		curSensor = getSensorCorrectingError();

		int discrapencyProportional = propRegulator();
		int discrapencyDifferential = diffRegulator();
		int discrapencyCube = cubeRegulator();

		int discrapency = discrapencyProportional + discrapencyDifferential + discrapencyCube;
		discrapency *= leftSide;

		//summingCorrection += discrapency;
		go(curSpeed, discrapency);
		nxtDisplayString(0, "go");

		recountEncoder();

		if((!waitingWall) && crossDetected){
			treatCrossDetected();
			crossDetected = false;
		}
		if((!waitingWall) && timeToPrepareForWall()){
			nxtDisplayString(3, "PREPARE FOR WALL");
			treatWall();
		}

		if(waitingWall && wallStart()){
			nxtDisplayString(3, "WALL");
			waitingWall = false;
			wall();
			nxtDisplayString(3, "WALL PASSED");
		}

		nxtDisplayString(1, "counting = %d", currentEncoder);
		nxtDisplayString(2, "discrap = %d", currentEncoderDelta);

		nxtDisplayString(4, "crossNumber = %d", crossNumber);
		nxtDisplayString(5, "ML = %d", nMotorEncoder[motorLeftIndex]);

		if( (!waitingWall) &&  goCountingEncoders){
			if(distancePassed()){
				/*
				if(abs(currentEncoderDelta) > currentEncoderDeltaBorder){
					makeActionCorner();
				} else {
				*/
				int actionType = ARCTION_ON_CROSS_IGNORE;
				if(crossNumber < actionsOnCrosses_size){
						actionType = actionsOnCrosses[crossNumber];
				}
				PlaySound(soundBeepBeep);
				if(actionType == ARCTION_ON_CROSS_KILL_BALL){
					stabilize();
					killBall();
				} else if(actionType == ARCTION_ON_CROSS_KILL_JAR){
					stabilize();
					killJar();
				} else if(actionType == ARCTION_ON_CROSS_IGNORE){
					nxtDisplayString(2, "IGNORE!");
				} else if(actionType == ARCTION_ON_CROSS_FULL_STOP){
					fullStop();
				}
				crossNumber++;
				/*
				}
				*/
				goCountingEncoders = false;
			}
		}
		wait1Msec(1);
	}
}
void killBall(){

	nxtDisplayString(2, "BALL");

	int killSpead = 50;


	stabilize();
	nMotorEncoder[motorLeftIndex] = 0;
	motor[motorLeftIndex] = killSpead;
	motor[motorRightIndex] = -killSpead;
  while (nMotorEncoder[motorLeftIndex]<rotate90Dist){
  	wait1Msec(10);
  }

  stabilize();
  nMotorEncoder[motorLeftIndex] = 0;
  motor[motorLeftIndex] = killSpead;
	motor[motorRightIndex] = killSpead;
  while (nMotorEncoder[motorLeftIndex]<touchBallDist){
  		wait1Msec(10);
  }

  stabilize();
  motor[motorLeftIndex] = -killSpead;
	motor[motorRightIndex] = -killSpead;
	while (nMotorEncoder[motorLeftIndex]>=0){
  		wait1Msec(10);
  }

	stabilize();
  nMotorEncoder[motorLeftIndex] = 0;
  motor[motorLeftIndex] = -killSpead;
	motor[motorRightIndex] = killSpead;
  while (nMotorEncoder[motorLeftIndex]>-rotate90Dist){
  	wait1Msec(10);
  }

  stabilize();

  nMotorEncoder[motorLeftIndex] = 0;
  motor[motorLeftIndex] = killSpead;
	motor[motorRightIndex] = killSpead;
  while (nMotorEncoder[motorLeftIndex]<20){
  	wait1Msec(10);
  }

  motor[motorLeftIndex] = 0;
	motor[motorRightIndex] = 0;
}





void killJar(){
	nxtDisplayString(2, "JAR");
	int killSpead = 50;


	stabilize();
	nMotorEncoder[motorLeftIndex] = 0;
	motor[motorLeftIndex] = -killSpead;
	motor[motorRightIndex] = killSpead;
  while (nMotorEncoder[motorLeftIndex]>-rotate90Dist){
  	wait1Msec(10);
  }

  stabilize();
  nMotorEncoder[motorLeftIndex] = 0;
  motor[motorLeftIndex] = killSpead;
	motor[motorRightIndex] = killSpead;
  while (nMotorEncoder[motorLeftIndex]<touchJarDist){
  		wait1Msec(10);
  }

  stabilize();
  motor[motorLeftIndex] = -killSpead;
	motor[motorRightIndex] = -killSpead;
	while (nMotorEncoder[motorLeftIndex]>=0){
  		wait1Msec(10);
  }

  nMotorEncoder[motorLeftIndex] = 0;

  motor[motorLeftIndex] = killSpead;
	motor[motorRightIndex] = -killSpead;
  while (nMotorEncoder[motorLeftIndex]<rotate90Dist){
  	wait1Msec(10);
  }

  stabilize();
  stabilize();
  stabilize();


  nMotorEncoder[motorLeftIndex] = 0;
  motor[motorLeftIndex] = killSpead;
	motor[motorRightIndex] = killSpead;
  while (nMotorEncoder[motorLeftIndex] < 30){
  	wait1Msec(10);
  }
  stabilize();


  motor[motorLeftIndex] = 0;
	motor[motorRightIndex] = 0;
}

void fullStop(){
	nxtDisplayString(2, "FULLSTOP");
	int hereSpeed = 50;


	nMotorEncoder[motorLeftIndex] = 0;
	motor[motorLeftIndex] = hereSpeed;
	motor[motorRightIndex] = hereSpeed;
  while (nMotorEncoder[motorLeftIndex]<distanceToStop){
  	wait1Msec(10);
  }
  motor[motorLeftIndex] = 0;
	motor[motorRightIndex] = 0;
  while(1);
}
