#pragma config(Motor,  motorA,          LEFT_MOTOR,    tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          RIGHT_MOTOR,   tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define WAIT_TIME    8.0
#define KGYROANGLE  7.5
#define KGYROSPEED  1.15
#define KPOS        0.14
#define KSPEED      0.2
#define OFFSET_SAMPLES 100
#define EMAOFFSET 0.0005

task main()
{
     const tSensors GyroSensor = (tSensors) S4;
     float tInterval = WAIT_TIME*0.001;
     float ratioWheel = 1.4;
     float gOffset;
     float gAngleGlobal = 0;
     long mrcAver = 0, mrcAverPrev;
     float gyroSpeed, gyroAngle;
     float motorSpeed;
     int power, powerLeft, powerRight;
     float gSum, GyroRaw;
     int  i, gMin, gMax, g;
     long mrcLeft, mrcRight;

     wait1Msec(50);
     do {
        gSum = 0.0;
        gMin = 1000;
        gMax = -1000;
        for (i=0; i<OFFSET_SAMPLES; i++) {
            g =   SensorValue(GyroSensor);

            if (g > gMax)
               gMax = g;
            if (g < gMin)
               gMin = g;
            gSum += g;
            wait1Msec(5);
            }
        } while ((gMax - gMin) > 1);
        gOffset = gSum / OFFSET_SAMPLES;
        nxtDisplayTextLine(4,"Balance in 3 second");

        wait1Msec(3000);
        PlayTone(440,100);
        eraseDisplay();

        while(true) {
            GyroRaw = SensorValue(GyroSensor);
            gOffset = EMAOFFSET * GyroRaw + (1-EMAOFFSET) * gOffset;
            gyroSpeed = GyroRaw - gOffset;
            gAngleGlobal += gyroSpeed*tInterval;
            gyroAngle = gAngleGlobal;
            mrcLeft = nMotorEncoder[LEFT_MOTOR];
            mrcRight = nMotorEncoder[RIGHT_MOTOR];
            mrcAverPrev = mrcAver;
            mrcAver = (mrcLeft + mrcRight)/2;
            motorSpeed = (mrcAver - mrcAverPrev)/tInterval;

            power = (KGYROSPEED * gyroSpeed +
              KGYROANGLE * gyroAngle)  +
              KPOS * mrcAver +
              KSPEED * motorSpeed;

            powerLeft = power;
            powerRight = power;
            if (powerLeft > 100)   powerLeft = 100;
            if (powerLeft < -100)  powerLeft = -100;
            if (powerRight > 100)  powerRight = 100;
            if (powerRight < -100) powerRight = -100;
            motor[LEFT_MOTOR] = powerLeft;
            motor[RIGHT_MOTOR] = powerRight;
            wait1Msec(WAIT_TIME);
  }

}
